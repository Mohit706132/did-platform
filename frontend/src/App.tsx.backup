// src/App.tsx
import React, { useEffect, useState } from "react";
import "./App.css";
import {
  getCurrentAddress,
  registerDidOnChain,
} from "./blockchain/didRegistry";
import { DID_METHOD_PREFIX } from "./blockchain/config";
import type { VerifiableCredential } from "./types/vc";

const BACKEND_URL = import.meta.env.VITE_BACKEND_URL || "http://localhost:4000";

interface User {
  email: string;
  firstName: string;
  lastName: string;
  did?: string;
  walletAddress?: string;
}

type ViewType = 'auth' | 'dashboard' | 'credentials' | 'verify' | 'wallet';

function App() {
  // Auth state
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [sessionId, setSessionId] = useState<string>("");
  const [user, setUser] = useState<User | null>(null);
  const [authView, setAuthView] = useState<'login' | 'register'>('login');
  
  // Form state
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  
  // Wallet state
  const [ethAddress, setEthAddress] = useState<string>("");
  const [did, setDid] = useState<string>("");
  const [walletConnected, setWalletConnected] = useState(false);
  
  // App state
  const [currentView, setCurrentView] = useState<ViewType>('auth');
  const [credentials, setCredentials] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [status, setStatus] = useState<{ type: 'success' | 'error' | 'info', message: string } | null>(null);
  
  // Modal state
  const [showCredentialModal, setShowCredentialModal] = useState(false);
  const [selectedCredential, setSelectedCredential] = useState<any>(null);
  
  // Verify state
  const [verifyInput, setVerifyInput] = useState("");
  const [verifyResult, setVerifyResult] = useState<any>(null);

  useEffect(() => {
    const stored = localStorage.getItem("did-platform-session");
    if (stored) {
      try {
        const data = JSON.parse(stored);
        setSessionId(data.sessionId);
        setUser(data.user);
        setIsAuthenticated(true);
        setCurrentView('dashboard');
        loadCredentials(data.sessionId);
      } catch (err) {
        console.error("Failed to restore session", err);
      }
    }
  }, []);

  const showStatus = (type: 'success' | 'error' | 'info', message: string) => {
    setStatus({ type, message });
    setTimeout(() => setStatus(null), 5000);
  };

  const handleRegister = async () => {
    if (!email || !password || !firstName || !lastName) {
      showStatus('error', 'All fields are required');
      return;
    }

    try {
      setLoading(true);
      const response = await fetch(`${BACKEND_URL}/api/auth/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password, firstName, lastName })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Registration failed');
      }

      const data = await response.json();
      setSessionId(data.sessionId);
      setUser({ email, firstName, lastName });
      setIsAuthenticated(true);
      setCurrentView('dashboard');
      
      localStorage.setItem("did-platform-session", JSON.stringify({
        sessionId: data.sessionId,
        user: { email, firstName, lastName }
      }));
      
      showStatus('success', 'Registration successful!');
      resetAuthForm();
    } catch (err: any) {
      showStatus('error', err.message || 'Registration failed');
    } finally {
      setLoading(false);
    }
  };

  const handleLogin = async () => {
    if (!email || !password) {
      showStatus('error', 'Email and password are required');
      return;
    }

    try {
      setLoading(true);
      const response = await fetch(`${BACKEND_URL}/api/auth/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Login failed');
      }

      const data = await response.json();
      setSessionId(data.sessionId);
      setUser(data.user);
      setIsAuthenticated(true);
      setCurrentView('dashboard');
      
      localStorage.setItem("did-platform-session", JSON.stringify({
        sessionId: data.sessionId,
        user: data.user
      }));
      
      showStatus('success', 'Login successful!');
      await loadCredentials(data.sessionId);
      resetAuthForm();
    } catch (err: any) {
      showStatus('error', err.message || 'Login failed');
    } finally {
      setLoading(false);
    }
  };

  const handleLogout = async () => {
    try {
      await fetch(`${BACKEND_URL}/api/auth/logout`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-session-id': sessionId
        }
      });
    } catch (err) {
      console.error("Logout error", err);
    }

    setIsAuthenticated(false);
    setSessionId("");
    setUser(null);
    setCurrentView('auth');
    setCredentials([]);
    setWalletConnected(false);
    setEthAddress("");
    setDid("");
    localStorage.removeItem("did-platform-session");
    showStatus('info', 'Logged out successfully');
  };

  const resetAuthForm = () => {
    setEmail("");
    setPassword("");
    setFirstName("");
    setLastName("");
  };



  const connectWallet = async () => {
    try {
      setLoading(true);
      setStatus(null);
      const addr = await getCurrentAddress();
      setEthAddress(addr);
      const myDid = `${DID_METHOD_PREFIX}${addr}`;
      setDid(myDid);
      setWalletConnected(true);
      showStatus('success', 'Wallet connected successfully!');
      
      // Get challenge for wallet verification
      await getWalletChallenge(addr);
    } catch (err: any) {
      showStatus('error', err.message || 'Failed to connect wallet');
    } finally {
      setLoading(false);
    }
  };

  const getWalletChallenge = async (walletAddress: string) => {
    try {
      const response = await fetch(`${BACKEND_URL}/api/auth/wallet/challenge`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-session-id': sessionId
        },
        body: JSON.stringify({ walletAddress })
      });

      if (!response.ok) {
        throw new Error('Failed to get wallet challenge');
      }

      const data = await response.json();
      showStatus('info', 'Please sign the message in MetaMask to verify wallet ownership');
    } catch (err: any) {
      showStatus('error', err.message || 'Failed to get wallet challenge');
    }
  };

  const loadCredentials = async (sid: string) => {
    try {
      const response = await fetch(`${BACKEND_URL}/api/credentials?page=1&limit=50`, {
        headers: { 'x-session-id': sid }
      });

      if (response.ok) {
        const data = await response.json();
        setCredentials(data.credentials || []);
      }
    } catch (err) {
      console.error("Failed to load credentials", err);
    }
  };

  const handleIssueCredential = async () => {
    if (!did && !ethAddress) {
      showStatus('error', 'Please connect your wallet first');
      return;
    }

    try {
      setLoading(true);
      const response = await fetch(`${BACKEND_URL}/api/credentials/issue`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-session-id': sessionId
        },
        body: JSON.stringify({
          subjectDid: did || `${DID_METHOD_PREFIX}${ethAddress}`,
          claims: {
            name: `${user?.firstName} ${user?.lastName}`,
            email: user?.email,
            role: "Student",
            university: "Demo University"
          },
          type: ["VerifiableCredential", "EducationCredential"]
        })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to issue credential');
      }

      const data = await response.json();
      showStatus('success', 'Credential issued successfully!');
      await loadCredentials(sessionId);
    } catch (err: any) {
      showStatus('error', err.message || 'Failed to issue credential');
    } finally {
      setLoading(false);
    }
  };

  const handleVerifyCredential = async () => {
    if (!verifyInput.trim()) {
      showStatus('error', 'Please paste a credential JSON');
      return;
    }

    try {
      setLoading(true);
      const parsed = JSON.parse(verifyInput);

      const response = await fetch(`${BACKEND_URL}/api/credentials/verify`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-session-id': sessionId
        },
        body: JSON.stringify(parsed)
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Verification failed');
      }

      const result = await response.json();
      setVerifyResult(result);
      showStatus(result.valid ? 'success' : 'error', 
        result.valid ? 'Credential is valid!' : `Credential is invalid: ${result.reason}`);
    } catch (err: any) {
      showStatus('error', err.message || 'Failed to verify credential');
      setVerifyResult(null);
    } finally {
      setLoading(false);
    }
  };

  const viewCredentialDetails = (credential: any) => {
    setSelectedCredential(credential);
    setShowCredentialModal(true);
  };

  const connectWallet = async () => {
    try {
      setStatus("Connecting wallet...");
      const addr = await getCurrentAddress();
      setEthAddress(addr);
      const myDid = `${DID_METHOD_PREFIX}${addr}`;
      setDid(myDid);
      setStatus(`Connected as ${addr}`);
    } catch (err: any) {
      console.error(err);
      setStatus(`Error connecting wallet: ${err.message ?? String(err)}`);
    }
  };

  const handleRegisterDid = async () => {
    if (!ethAddress) {
      setStatus("Connect wallet first.");
      return;
    }
    if (!didDocUriInput) {
      setStatus("Please enter a DID Document URI (can be any string for now).");
      return;
    }

    try {
      setLoading(true);
      setStatus("Registering DID on-chain...");
      await registerDidOnChain(didDocUriInput);
      setStatus("DID registered successfully!");

      const res = await resolveDid(ethAddress);
      console.log("Resolved DID record:", res);
    } catch (err: any) {
      console.error(err);
      setStatus(`Error registering DID: ${err.message ?? String(err)}`);
    } finally {
      setLoading(false);
    }
  };

  const requestCredential = async () => {
    if (!did) {
      setStatus("Connect wallet first to get your DID.");
      return;
    }

    try {
      setLoading(true);
      setStatus("Requesting credential from issuer...");

      const response = await fetch(`${BACKEND_URL}/issue`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          subjectDid: did,
          claims: {
            name: "Demo User",
            role: "Student",
            university: "XYZ Institute"
          }
        })
      });

      if (!response.ok) {
        const t = await response.text();
        throw new Error(`Issuer error: ${response.status} ${t}`);
      }

      const vc = (await response.json()) as VerifiableCredential;
      setCredentials((prev) => [...prev, vc]);
      setStatus("Credential received and stored in wallet.");
    } catch (err: any) {
      console.error(err);
      setStatus(`Error requesting credential: ${err.message ?? String(err)}`);
    } finally {
      setLoading(false);
    }
  };

  const clearCredentials = () => {
    setCredentials([]);
    localStorage.removeItem("walletCredentials");
    setStatus("Cleared stored credentials.");
  };

  return (
    <div className="app-root">
      <h1>My DID Wallet</h1>

      <section className="card">
        <h2>1. Connect Ethereum Wallet</h2>
        <button onClick={connectWallet}>Connect MetaMask</button>
        {ethAddress && (
          <>
            <p><strong>Address:</strong> {ethAddress}</p>
            <p><strong>DID:</strong> {did}</p>
          </>
        )}
      </section>

      <section className="card">
        <h2>2. Register DID on Blockchain</h2>
        <p>
          Enter a DID Document URI (for now, you can just put any URL or short JSON
          describing your public keys).
        </p>
        <input
          type="text"
          value={didDocUriInput}
          onChange={(e) => setDidDocUriInput(e.target.value)}
          placeholder="https://example.com/did/your-did.json"
          style={{ width: "100%" }}
        />
        <button onClick={handleRegisterDid} disabled={loading}>
          {loading ? "Registering..." : "Register DID"}
        </button>
      </section>

      <section className="card">
        <h2>3. Request a Verifiable Credential</h2>
        <p>
          This will call the backend issuer and ask for a basic student credential
          for your DID.
        </p>
        <button onClick={requestCredential} disabled={loading}>
          {loading ? "Requesting..." : "Request Credential"}
        </button>
        <button onClick={clearCredentials} style={{ marginLeft: "0.5rem" }}>
          Clear Stored Credentials
        </button>
      </section>

      <section className="card">
        <h2>4. Stored Credentials</h2>
        {credentials.length === 0 && <p>No credentials stored yet.</p>}
        {credentials.map((vc, idx) => (
          <details key={vc.id + idx} style={{ marginBottom: "1rem" }}>
            <summary>{vc.type.join(", ")} â€“ {vc.id}</summary>
            <pre style={{ whiteSpace: "pre-wrap", wordBreak: "break-all" }}>
              {JSON.stringify(vc, null, 2)}
            </pre>
          </details>
        ))}
      </section>
            <section className="card">
        <h2>5. Verify a Credential</h2>
        <p>Paste a Verifiable Credential JSON below and click "Verify".</p>
        <textarea
          style={{ width: "100%", minHeight: "160px" }}
          value={verifyInput}
          onChange={(e) => setVerifyInput(e.target.value)}
          placeholder="Paste VC JSON here..."
        />
        <button onClick={handleVerifyCredential} disabled={loading}>
          {loading ? "Verifying..." : "Verify Credential"}
        </button>
        {verifyResult && (
          <p style={{ marginTop: "0.5rem", whiteSpace: "pre-wrap" }}>{verifyResult}</p>
        )}
      </section>


      <section className="status">
        <strong>Status:</strong> {status || "Idle"}
      </section>

            <section className="card">
        <h2>6. Backup & Recovery</h2>
        <p>
          Create an encrypted backup of your wallet state (DID, address, and credentials).
          The encryption key is derived from your password. Keep the password safe!
        </p>

        <h3>Create Backup</h3>
        <input
          type="password"
          placeholder="Backup password"
          value={backupPassword}
          onChange={(e) => setBackupPassword(e.target.value)}
          style={{ width: "100%", marginBottom: "0.5rem" }}
        />
        <button onClick={handleCreateBackup}>Create Encrypted Backup</button>

        {backupData && (
          <>
            <p style={{ marginTop: "0.5rem" }}>Encrypted backup blob (copy & store somewhere safe):</p>
            <textarea
              style={{ width: "100%", minHeight: "100px" }}
              value={backupData}
              onChange={(e) => setBackupData(e.target.value)}
            />
          </>
        )}

        <h3 style={{ marginTop: "1rem" }}>Restore from Backup</h3>
        <p>Paste your encrypted backup blob above and enter the original password.</p>
        <input
          type="password"
          placeholder="Restore password"
          value={restorePassword}
          onChange={(e) => setRestorePassword(e.target.value)}
          style={{ width: "100%", marginBottom: "0.5rem" }}
        />
        <button onClick={handleRestoreBackup}>Restore Backup</button>

        {backupMessage && (
          <p style={{ marginTop: "0.5rem" }}>{backupMessage}</p>
        )}
      </section>

    </div>
  );
}

export default App;
